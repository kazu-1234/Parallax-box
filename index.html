<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Parallax World v6.0.0</title>
    <style>
        /* * „Éê„Éº„Ç∏„Éß„É≥: v6.0.0
         * Â§âÊõ¥ÁÇπ: „Ç∑„Éç„Éû„É¢„Éº„Éâ(YouTubeÊ©üËÉΩ)„ÇíÂâäÈô§„Åó„ÄÅBOX„Å®DANCE„É¢„Éº„Éâ„ÅÆ„Åø„Å´ËªΩÈáèÂåñ
         */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            color: white;
            touch-action: none;
            user-select: none; 
            -webkit-user-select: none;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #webgl-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
        }

        #controls-container {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            pointer-events: auto;
        }

        .control-group {
            background: rgba(20, 20, 30, 0.85);
            border: 1px solid #444;
            border-radius: 20px;
            padding: 5px;
            display: flex;
            gap: 2px;
            backdrop-filter: blur(5px);
        }

        .ctrl-btn {
            background: transparent;
            border: none;
            color: #888;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .ctrl-btn:hover {
            color: #ccc;
            background: rgba(255, 255, 255, 0.1);
        }

        .ctrl-btn.active {
            color: #000;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
        }

        #mode-group .active { background: #00d2ff; }
        #scene-group .active { background: #ff0055; }

        /* Ë®≠ÂÆö„Éú„Çø„É≥ */
        #settings-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(50, 50, 60, 0.9);
            border: 1px solid #666;
            color: white;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.3s;
        }
        #settings-btn:hover { background: rgba(70, 70, 80, 1.0); }
        #settings-btn:active { transform: rotate(90deg); }

        #settings-panel {
            position: absolute;
            top: 60px;
            right: 10px;
            width: 200px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #444;
            border-radius: 15px;
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .setting-label {
            font-size: 12px;
            color: #ccc;
            display: flex;
            justify-content: space-between;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #00d2ff;
            cursor: pointer;
            margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #444;
            border-radius: 2px;
        }

        #reset-sensitivity {
            font-size: 10px;
            background: #333;
            border: none;
            color: #aaa;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            align-self: flex-end;
        }
        #reset-sensitivity:hover { color: white; background: #555; }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            transition: opacity 0.5s;
        }

        .overlay-content { text-align: center; padding: 20px; max-width: 90%; }
        h1 { font-size: 2.5rem; margin-bottom: 10px; background: linear-gradient(45deg, #00d2ff, #ff0055); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .action-btn { padding: 15px 50px; font-size: 1.2rem; background: linear-gradient(90deg, #00d2ff, #0077ff); border: none; border-radius: 50px; color: white; cursor: pointer; box-shadow: 0 4px 20px rgba(0, 119, 255, 0.5); font-weight: bold; margin-top: 20px; }
        .action-btn:hover { transform: scale(1.05); }
        .action-btn:active { transform: scale(0.95); }
        
        #loading { margin-top: 20px; color: #00d2ff; font-family: monospace; display: none; }

        .device-info {
            margin-top: 20px;
            font-size: 13px;
            color: #888;
            background: rgba(255,255,255,0.05);
            padding: 10px 20px;
            border-radius: 10px;
            line-height: 1.6;
        }
        .icon-key {
            display: inline-block;
            border: 1px solid #666;
            border-radius: 4px;
            padding: 0 4px;
            font-size: 10px;
            margin: 0 2px;
        }

        #camera-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 133px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #333;
            background: #000;
            display: none;
            transform: scaleX(-1);
            pointer-events: auto;
        }
        #camera-preview canvas { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

    <div id="container">
        <!-- 3D„É¢„Éá„É´„É¨„Ç§„É§„Éº -->
        <div id="webgl-container"></div>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div id="controls-container">
            <button id="settings-btn" onclick="toggleSettings()" title="Settings">‚öôÔ∏è</button>
            
            <div class="control-group" id="scene-group">
                <button class="ctrl-btn active" onclick="switchScene('box')">üì¶ BOX</button>
                <button class="ctrl-btn" onclick="switchScene('dance')">ü§ñ DANCE</button>
            </div>
            
            <div class="control-group" id="mode-group">
                <button class="ctrl-btn active" id="btn-gyro" onclick="switchMode('gyro')">GYRO</button>
                <button class="ctrl-btn" id="btn-touch" onclick="switchMode('touch')">TOUCH</button>
                <button class="ctrl-btn" id="btn-face" onclick="switchMode('face')">FACE</button>
            </div>
        </div>

        <!-- Settings Panel -->
        <div id="settings-panel">
            <div class="setting-label">
                <span>SENSITIVITY</span>
                <span id="sensitivity-val">100%</span>
            </div>
            <input type="range" id="sensitivity-slider" min="10" max="300" value="100">
            <button id="reset-sensitivity" onclick="resetSensitivity()">RESET</button>
        </div>

        <div id="camera-preview">
            <canvas id="debug-canvas"></canvas>
        </div>
    </div>

    <!-- Start Overlay -->
    <div id="start-overlay">
        <div class="overlay-content">
            <h1>Parallax World</h1>
            <p style="color:#ccc; margin-bottom: 5px;">
                ÁÆ±Â∫≠„Å®„É≠„Éú„ÉÉ„Éà„ÉÄ„É≥„Çπ„ÄÇ<br>
                Â••Ë°å„Åç„ÅÆ„ÅÇ„ÇãÁ©∫Èñì‰ΩìÈ®ì„Çí„ÄÇ
            </p>
            
            <div class="device-info" id="start-guide">
                Wait for device detection...
            </div>

            <button class="action-btn" id="main-start-btn">ENTER</button>
            <div id="loading">Loading 3D Resources...</div>
        </div>
    </div>

    <video id="input-video" style="display:none;" playsinline webkit-playsinline></video>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- CSS3DRenderer„ÅØ‰∏çË¶Å„Å´„Å™„Å£„Åü„Åü„ÇÅÂâäÈô§ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

    <script>
        /**
         * „Éê„Éº„Ç∏„Éß„É≥: v6.0.0
         * Ê©üËÉΩ: „Ç∑„Éç„Éû„É¢„Éº„ÉâÂâäÈô§„Å´„Çà„ÇãËªΩÈáèÂåñ„ÄÇBox/Dance„É¢„Éº„Éâ„ÅÆ„Åø„Çµ„Éù„Éº„Éà„ÄÇ
         */

        // --- Configuration ---
        const BASE_SENSITIVITY = {
            gyro: { x: 15, y: 15 },
            face: { x: 600, y: 500 },
            touch: { x: 250, y: 250 },
            keyboard: { x: 300, y: 300 }
        };

        const CONFIG = {
            sensitivityMultiplier: 1.0,
            smoothing: 0.08,
            roomSize: 600,
            depth: 800,
            keyboardSpeed: 5
        };

        // --- Global State ---
        let currentMode = 'gyro';
        let currentScene = 'box';
        let isStarted = false;
        
        let targetPos = { x: 0, y: 0 };
        let currentPos = { x: 0, y: 0 };

        let virtualCursor = { x: 0, y: 0 }; 
        let keysPressed = {};

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Three.js
        let scene, camera, renderer;
        let roomGroup;
        
        // Objects
        let boxObjects = [];
        let robotModel = null;
        let mixer = null;
        
        // Animations
        let robotActions = {};
        let activeAction = null;

        // MediaPipe
        let faceMesh, cameraUtils;
        let isFaceMeshLoaded = false;
        const videoElement = document.getElementById('input-video');
        const debugCanvas = document.getElementById('debug-canvas');
        const debugCtx = debugCanvas.getContext('2d');
        const clock = new THREE.Clock();

        // --- Initialization ---
        window.onload = () => {
            detectDeviceAndSetMode();
            initThreeJS();
            setupInputEvents();
            setupSettingsUI();

            document.getElementById('main-start-btn').addEventListener('click', async () => {
                const overlay = document.getElementById('start-overlay');
                const loading = document.getElementById('loading');
                const btn = document.getElementById('main-start-btn');
                
                btn.style.display = 'none';
                loading.style.display = 'block';

                await loadRobotModel();
                
                loading.style.display = 'none';
                overlay.style.opacity = '0';
                setTimeout(()=> overlay.style.display = 'none', 500);
                isStarted = true;

                if (currentMode === 'gyro' && isMobile) requestGyroPermission();
                
                switchScene('box');
            });
        };

        // --- Device Detection ---
        function detectDeviceAndSetMode() {
            const guide = document.getElementById('start-guide');
            const gyroBtn = document.getElementById('btn-gyro');
            
            if (isMobile) {
                currentMode = 'gyro';
                gyroBtn.style.display = 'block';
                guide.innerHTML = `
                    üì± <b>Mobile Mode</b><br>
                    ÂÇæ„Åç(Gyro) „ÇÑ „Çø„ÉÉ„ÉÅÊìç‰Ωú„ÅßË¶ñÁÇπÁßªÂãï<br>
                    <span style="font-size:11px; opacity:0.8;">‚Äª„Ç´„É°„É©Ë®±ÂèØ„ÅßÈ°îË™çË≠ò„É¢„Éº„Éâ„ÇÇÂà©Áî®ÂèØ</span>
                `;
            } else {
                currentMode = 'touch';
                gyroBtn.style.display = 'none';
                guide.innerHTML = `
                    üíª <b>PC Mode</b><br>
                    „Éû„Ç¶„ÇπÁßªÂãï / „Ç≠„Éº„Éú„Éº„ÉâÊìç‰Ωú / <b>Web„Ç´„É°„É©(Face)</b><br>
                    <span class="icon-key">W</span><span class="icon-key">A</span><span class="icon-key">S</span><span class="icon-key">D</span> 
                    / <span class="icon-key">‚Üë</span><span class="icon-key">‚Üê</span><span class="icon-key">‚Üì</span><span class="icon-key">‚Üí</span>
                `;
            }
            updateModeUI();
        }

        // --- Settings Logic ---
        function toggleSettings() {
            const panel = document.getElementById('settings-panel');
            panel.style.display = (panel.style.display === 'flex') ? 'none' : 'flex';
        }

        function setupSettingsUI() {
            const slider = document.getElementById('sensitivity-slider');
            const display = document.getElementById('sensitivity-val');
            slider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                CONFIG.sensitivityMultiplier = val / 100;
                display.innerText = `${val}%`;
            });
        }

        function resetSensitivity() {
            const slider = document.getElementById('sensitivity-slider');
            const display = document.getElementById('sensitivity-val');
            slider.value = 100;
            CONFIG.sensitivityMultiplier = 1.0;
            display.innerText = "100%";
        }

        // --- Scene & Mode Switching ---
        function switchMode(mode) {
            if (mode === currentMode) return;
            currentMode = mode;
            updateModeUI();
            
            virtualCursor = { x: 0, y: 0 };
            targetPos = { x: 0, y: 0 };

            if (isStarted && mode === 'face' && !isFaceMeshLoaded) startCameraMode();
        }

        function updateModeUI() {
            document.querySelectorAll('#mode-group .ctrl-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById(`btn-${currentMode}`);
            if(btn) btn.classList.add('active');

            const preview = document.getElementById('camera-preview');
            preview.style.display = (currentMode === 'face' && isStarted) ? 'block' : 'none';
        }

        function switchScene(sceneType) {
            currentScene = sceneType;

            document.querySelectorAll('#scene-group .ctrl-btn').forEach(b => b.classList.remove('active'));
            const btns = document.querySelectorAll('#scene-group .ctrl-btn');
            if(sceneType === 'box') btns[0].classList.add('active');
            if(sceneType === 'dance') btns[1].classList.add('active');

            if(roomGroup) roomGroup.visible = true; // Box/Dance„ÅØÂêå„ÅòÈÉ®Â±ã„Çí‰Ωø„ÅÜ

            boxObjects.forEach(cube => cube.visible = (sceneType === 'box'));
            if (robotModel) robotModel.visible = (sceneType === 'dance');
        }

        // --- Three.js Setup ---
        function initThreeJS() {
            const container = document.getElementById('webgl-container');
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.001);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(0, 0, 400);

            createRoom();

            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xffffff, 2.0);
            spotLight.position.set(0, 400, 400);
            spotLight.angle = Math.PI / 3;
            spotLight.penumbra = 0.5;
            spotLight.castShadow = true;
            scene.add(spotLight);

            const pLight1 = new THREE.PointLight(0x00d2ff, 1.5, 1200);
            pLight1.position.set(-300, 100, 0);
            scene.add(pLight1);
            
            const pLight2 = new THREE.PointLight(0xff0055, 1.5, 1200);
            pLight2.position.set(300, 100, 0);
            scene.add(pLight2);

            window.addEventListener('resize', onResize);
            animate();
        }

        // --- Room Construction ---
        function createRoom() {
            roomGroup = new THREE.Group();
            scene.add(roomGroup);

            const s = CONFIG.roomSize;
            const d = CONFIG.depth;
            const wallSize = 5000;
            const wallMat = new THREE.MeshPhongMaterial({ color: 0x0a0a0a, side: THREE.FrontSide, shininess: 10 });
            function createGrid(size, divisions, color1, color2) { return new THREE.GridHelper(size, divisions, color1, color2); }

            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(wallSize, wallSize), wallMat);
            backWall.position.z = -d/2; backWall.receiveShadow = true; roomGroup.add(backWall);
            const gridBack = createGrid(wallSize, 100, 0x00d2ff, 0x111111);
            gridBack.rotation.x = Math.PI/2; gridBack.position.z = -d/2+2; roomGroup.add(gridBack);

            const floor = new THREE.Mesh(new THREE.PlaneGeometry(wallSize, wallSize), wallMat);
            floor.rotation.x = -Math.PI/2; floor.position.y = -s/2; floor.receiveShadow = true; roomGroup.add(floor);
            const gridBottom = createGrid(wallSize, 100, 0x00ffaa, 0x111111);
            gridBottom.position.y = -s/2+2; roomGroup.add(gridBottom);

            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(wallSize, wallSize), wallMat);
            ceiling.rotation.x = Math.PI/2; ceiling.position.y = s/2; roomGroup.add(ceiling);
            const gridTop = createGrid(wallSize, 100, 0xff0055, 0x111111);
            gridTop.position.y = s/2-2; roomGroup.add(gridTop);

            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(wallSize, wallSize), wallMat);
            leftWall.rotation.y = Math.PI/2; leftWall.position.x = -s/2; leftWall.receiveShadow = true; roomGroup.add(leftWall);
            const gridLeft = createGrid(wallSize, 100, 0x888888, 0x111111);
            gridLeft.rotation.z = Math.PI/2; gridLeft.position.x = -s/2+2; roomGroup.add(gridLeft);

            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(wallSize, wallSize), wallMat);
            rightWall.rotation.y = -Math.PI/2; rightWall.position.x = s/2; rightWall.receiveShadow = true; roomGroup.add(rightWall);
            const gridRight = createGrid(wallSize, 100, 0x888888, 0x111111);
            gridRight.rotation.z = Math.PI/2; gridRight.position.x = s/2-2; roomGroup.add(gridRight);

            const cubeGeo = new THREE.BoxGeometry(40, 40, 40);
            for (let i = 0; i < 40; i++) {
                const material = new THREE.MeshPhongMaterial({ color: Math.random()>0.5?0x00d2ff:0xff0055, shininess: 80, transparent: true, opacity: 0.9 });
                const cube = new THREE.Mesh(cubeGeo, material);
                cube.position.set((Math.random()-0.5)*(s-100), (Math.random()-0.5)*(s-100), -Math.random()*(d-150)+50);
                cube.userData = { rotX: (Math.random()-0.5)*0.03, rotY: (Math.random()-0.5)*0.03 };
                cube.castShadow = true; cube.receiveShadow = true;
                roomGroup.add(cube);
                boxObjects.push(cube);
            }
        }

        // --- Robot (RobotExpressive) ---
        function loadRobotModel() {
            return new Promise((resolve) => {
                const loader = new THREE.GLTFLoader();
                const url = 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb';
                
                loader.load(url, (gltf) => {
                    robotModel = gltf.scene;
                    
                    robotModel.scale.set(50, 50, 50);
                    robotModel.position.set(0, -180, -100);
                    
                    robotModel.traverse((c) => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
                    
                    mixer = new THREE.AnimationMixer(robotModel);
                    
                    const clips = gltf.animations;
                    const actionNames = ['Dance', 'Jump', 'Punch', 'Running'];
                    
                    actionNames.forEach(name => {
                        const clip = THREE.AnimationClip.findByName(clips, name);
                        if(clip) robotActions[name] = mixer.clipAction(clip);
                    });

                    function playRandomAction() {
                        const keys = Object.keys(robotActions);
                        if (keys.length === 0) return;
                        
                        const randKey = keys[Math.floor(Math.random() * keys.length)];
                        const nextAction = robotActions[randKey];
                        
                        if (activeAction && activeAction !== nextAction) {
                            activeAction.fadeOut(0.5);
                        }
                        
                        nextAction.reset();
                        
                        // Jump„ÅÆ„Åø„Çπ„É≠„Éº
                        if (randKey === 'Jump') {
                            nextAction.setEffectiveTimeScale(0.75);
                        } else {
                            nextAction.setEffectiveTimeScale(1.5);
                        }

                        nextAction.setEffectiveWeight(1);
                        nextAction.fadeIn(0.5);
                        nextAction.play();
                        
                        activeAction = nextAction;

                        setTimeout(playRandomAction, 3000 + Math.random() * 2000);
                    }

                    playRandomAction();
                    
                    robotModel.visible = false;
                    roomGroup.add(robotModel);
                    resolve();
                }, undefined, (e) => { console.error(e); resolve(); });
            });
        }

        // --- Inputs ---
        function setupInputEvents() {
            document.addEventListener('mousemove', (e) => { 
                if (currentMode === 'touch') {
                    handleInput(e.clientX, e.clientY);
                    const nx = (e.clientX / window.innerWidth) * 2 - 1;
                    const ny = (e.clientY / window.innerHeight) * 2 - 1;
                    virtualCursor.x = nx;
                    virtualCursor.y = ny;
                }
            });

            document.addEventListener('touchmove', (e) => { 
                if (currentMode === 'touch' && e.touches.length > 0) {
                    handleInput(e.touches[0].clientX, e.touches[0].clientY);
                }
            }, { passive: false });

            document.addEventListener('keydown', (e) => {
                keysPressed[e.code] = true;
                if (!isMobile && currentMode !== 'touch') switchMode('touch');
            });
            document.addEventListener('keyup', (e) => {
                keysPressed[e.code] = false;
            });
        }

        function handleInput(x, y) {
            const nx = (x / window.innerWidth) * 2 - 1;
            const ny = (y / window.innerHeight) * 2 - 1;
            targetPos.x = nx * BASE_SENSITIVITY.touch.x * CONFIG.sensitivityMultiplier;
            targetPos.y = -ny * BASE_SENSITIVITY.touch.y * CONFIG.sensitivityMultiplier;
        }

        function updateKeyboardInput() {
            if (currentMode !== 'touch') return;

            const speed = 0.03;
            let moved = false;

            if (keysPressed['ArrowRight'] || keysPressed['KeyD']) { virtualCursor.x += speed; moved = true; }
            if (keysPressed['ArrowLeft'] || keysPressed['KeyA']) { virtualCursor.x -= speed; moved = true; }
            if (keysPressed['ArrowDown'] || keysPressed['KeyS']) { virtualCursor.y += speed; moved = true; }
            if (keysPressed['ArrowUp'] || keysPressed['KeyW']) { virtualCursor.y -= speed; moved = true; }

            if (moved) {
                virtualCursor.x = Math.max(-1.5, Math.min(1.5, virtualCursor.x));
                virtualCursor.y = Math.max(-1.5, Math.min(1.5, virtualCursor.y));
                targetPos.x = virtualCursor.x * BASE_SENSITIVITY.keyboard.x * CONFIG.sensitivityMultiplier;
                targetPos.y = -virtualCursor.y * BASE_SENSITIVITY.keyboard.y * CONFIG.sensitivityMultiplier;
            }
        }

        function requestGyroPermission() {
            if (typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function') {
                DeviceOrientationEvent.requestPermission().then(r => { if(r==='granted') window.addEventListener('deviceorientation', handleGyro); });
            } else window.addEventListener('deviceorientation', handleGyro);
        }
        function handleGyro(e) {
            if (currentMode !== 'gyro') return;
            const x = e.gamma; const y = e.beta;
            if (x!=null && y!=null) {
                targetPos.x = x * BASE_SENSITIVITY.gyro.x * CONFIG.sensitivityMultiplier;
                targetPos.y = -(y - 45) * BASE_SENSITIVITY.gyro.y * CONFIG.sensitivityMultiplier;
            }
        }

        async function startCameraMode() {
            try {
                faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
                faceMesh.setOptions({maxNumFaces:1, minDetectionConfidence:0.5, minTrackingConfidence:0.5});
                faceMesh.onResults(onFaceResults);
                cameraUtils = new Camera(videoElement, { onFrame: async () => await faceMesh.send({image: videoElement}), width: 640, height: 480 });
                await cameraUtils.start();
                isFaceMeshLoaded = true;
            } catch(e) { console.error(e); alert("„Ç´„É°„É©Ëµ∑Âãï„Ç®„É©„Éº: Web„Ç´„É°„É©„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ"); }
        }
        function onFaceResults(results) {
            if (currentMode !== 'face') return;
            debugCanvas.width = videoElement.videoWidth; debugCanvas.height = videoElement.videoHeight;
            debugCtx.save(); debugCtx.clearRect(0,0,debugCanvas.width, debugCanvas.height);
            debugCtx.drawImage(results.image,0,0,debugCanvas.width, debugCanvas.height);
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const nose = results.multiFaceLandmarks[0][4];
                targetPos.x = -(nose.x - 0.5) * BASE_SENSITIVITY.face.x * CONFIG.sensitivityMultiplier;
                targetPos.y = -(nose.y - 0.5) * BASE_SENSITIVITY.face.y * CONFIG.sensitivityMultiplier;
                debugCtx.beginPath(); debugCtx.arc(nose.x*debugCanvas.width, nose.y*debugCanvas.height, 5, 0, 2*Math.PI);
                debugCtx.fillStyle = '#00ffaa'; debugCtx.fill();
            }
            debugCtx.restore();
        }

        // --- Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            updateKeyboardInput();

            currentPos.x += (targetPos.x - currentPos.x) * CONFIG.smoothing;
            currentPos.y += (targetPos.y - currentPos.y) * CONFIG.smoothing;

            camera.position.x = currentPos.x;
            camera.position.y = currentPos.y;
            camera.lookAt(0, 0, -200);

            if (mixer && currentScene === 'dance') mixer.update(delta);
            if (currentScene === 'box') {
                boxObjects.forEach(cube => { cube.rotation.x += cube.userData.rotX; cube.rotation.y += cube.userData.rotY; });
            }
            
            if(roomGroup) {
                roomGroup.position.x = -currentPos.x * 0.2;
                roomGroup.position.y = -currentPos.y * 0.2;
            }

            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>
</body>
</html>
